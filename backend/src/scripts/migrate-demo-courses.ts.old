import { PrismaClient, AviationCategory, CourseModality, VerificationStatus } from '@prisma/client';
import { demoCoursesData } from '../../../frontend/src/data/demoData';

const prisma = new PrismaClient();

// Mapping des cat√©gories de d√©mo vers les enums Prisma
const categoryMapping: Record<string, AviationCategory> = {
  'S√©curit√© A√©roportuaire': AviationCategory.security,
  'Langues Techniques': AviationCategory.operations, // Pas de category language, on mappe sur operations
  'Maintenance A√©ronautique': AviationCategory.maintenance,
  'Contr√¥le A√©rien': AviationCategory.operations, // Pas de atc, on mappe sur operations
  'Pilotage': AviationCategory.pilot_training,
  'Operations A√©roportuaires': AviationCategory.ground_handling,
  'Personnel Navigant': AviationCategory.cabin_crew,
  'Fabrication A√©ronautique': AviationCategory.maintenance, // Pas de manufacturing, on mappe sur maintenance
};

// Mapping des types de formation
const courseTypeMapping: Record<string, CourseModality> = {
  'online': CourseModality.online,
  'in-person': CourseModality.in_person,
  'virtual': CourseModality.online, // On mappe virtual sur online
  'blended': CourseModality.blended,
  'hybrid': CourseModality.blended, // On mappe hybrid sur blended
};

// Extraire le nombre d'heures d'une cha√Æne de dur√©e
function extractHours(duration: string): number {
  const match = duration.match(/(\d+)\s*heures?/i);
  return match ? parseInt(match[1]) : 0;
}

// G√©n√©rer des sessions futures
function generateFutureSessions(courseId: string, sessions: any[]): any[] {
  const now = new Date();
  const futureSessions: any[] = [];

  for (let i = 0; i < sessions.length; i++) {
    const session = sessions[i];
    const monthsToAdd = 2 + (i * 2); // Sessions espac√©es de 2 mois
    
    const startDate = new Date(now.getFullYear(), now.getMonth() + monthsToAdd, 15);
    const endDate = new Date(startDate);
    
    // Calculer la dur√©e en fonction du type de formation
    if (session.startDate && session.endDate) {
      const originalDuration = new Date(session.endDate).getTime() - new Date(session.startDate).getTime();
      endDate.setTime(startDate.getTime() + originalDuration);
    } else {
      endDate.setDate(startDate.getDate() + 1); // Par d√©faut 1 jour
    }

    futureSessions.push({
      course_id: courseId,
      start_date: startDate,
      end_date: endDate,
      price: parseFloat(session.price) || 0,
      available_seats: parseInt(session.availableSeats) || 20,
      max_seats: (parseInt(session.availableSeats) || 20) + 5, // Un peu plus de places max
      location: session.location || 'En ligne',
    });
  }

  return futureSessions;
}

async function migrateDemoCourses() {
  console.log('üöÄ D√©but de la migration des formations de d√©mo...');
  
  try {
    // 1. V√©rifier si on a d√©j√† des formations de d√©mo
    const existingCourses = await prisma.course.findMany({
      where: {
        title: {
          in: demoCoursesData.map(c => c.title)
        }
      }
    });

    if (existingCourses.length > 0) {
      console.log('‚ö†Ô∏è  Des formations de d√©mo existent d√©j√†. Mise √† jour des champs manquants...');
      
      // Mettre √† jour les formations existantes avec les nouveaux champs
      for (const demoCourse of demoCoursesData) {
        const existing = existingCourses.find(c => c.title === demoCourse.title);
        if (existing) {
          await prisma.course.update({
            where: { id: existing.id },
            data: {
              language: demoCourse.language,
              classification_number: demoCourse.classificationNumber,
              success_rate: demoCourse.successRate,
              satisfaction_rate: demoCourse.satisfactionRate,
              validity_duration: demoCourse.validityDuration,
              target_certification: demoCourse.targetCertification,
              program_pdf_url: demoCourse.programPdfUrl,
              duration: demoCourse.duration,
              cpf_eligible: demoCourse.cpfEligible,
              opco_eligible: demoCourse.opcoEligible,
            }
          });
          console.log(`‚úÖ Mise √† jour : ${demoCourse.title}`);
        }
      }
      
      console.log('üéâ Mise √† jour termin√©e !');
      return;
    }

    // 2. Cr√©er les organismes de formation uniques
    const uniqueProviders = [...new Set(demoCoursesData.map(c => c.provider))];
    const providerMap = new Map<string, string>();

    for (const providerName of uniqueProviders) {
      // V√©rifier si l'OF existe d√©j√†
      let provider = await prisma.trainingOrganization.findFirst({
        where: { organization_name: providerName }
      });

      if (!provider) {
        // R√©cup√©rer un utilisateur avec le r√¥le training_org ou cr√©er un utilisateur syst√®me
        let trainingOrgUser = await prisma.userProfile.findFirst({
          where: { role: 'training_org' }
        });

        if (!trainingOrgUser) {
          // Cr√©er un utilisateur syst√®me pour les donn√©es de d√©mo
          trainingOrgUser = await prisma.userProfile.create({
            data: {
              email: `contact@${providerName.toLowerCase().replace(/\s+/g, '-')}.fr`,
              role: 'training_org',
              first_name: 'Demo',
              last_name: providerName,
            }
          });
        }

        // Cr√©er l'OF
        provider = await prisma.trainingOrganization.create({
          data: {
            user_id: trainingOrgUser.id,
            organization_name: providerName,
            description: `Organisme de formation sp√©cialis√© - ${providerName}`,
            verification_status: VerificationStatus.verified,
            qualiopi_certified: true,
            logo_url: `/images/logos/${providerName.toLowerCase().replace(/\s+/g, '-')}-logo.png`,
          }
        });
        console.log(`‚úÖ OF cr√©√© : ${providerName}`);
      }
      
      providerMap.set(providerName, provider.id);
    }

    // 3. Cr√©er les formations
    for (const demoCourse of demoCoursesData) {
      const providerId = providerMap.get(demoCourse.provider);
      if (!providerId) {
        console.error(`‚ùå Provider non trouv√© pour : ${demoCourse.provider}`);
        continue;
      }

      // Cr√©er la formation
      const course = await prisma.course.create({
        data: {
          title: demoCourse.title,
          provider_id: providerId,
          description: demoCourse.description,
          category: categoryMapping[demoCourse.category] || AviationCategory.operations,
          objectives: demoCourse.objectives,
          requirements: demoCourse.requirements,
          target_audience: demoCourse.targetAudience,
          program: demoCourse.program,
          qualiopi_indicators: demoCourse.qualiopiIndicators || [],
          course_type: courseTypeMapping[demoCourse.type] || CourseModality.online,
          image_url: demoCourse.image,
          status: demoCourse.status === 'published' ? 'published' : 'draft',
          duration_hours: extractHours(demoCourse.duration),
          // Nouveaux champs
          language: demoCourse.language,
          classification_number: demoCourse.classificationNumber,
          success_rate: demoCourse.successRate,
          satisfaction_rate: demoCourse.satisfactionRate,
          validity_duration: demoCourse.validityDuration,
          target_certification: demoCourse.targetCertification,
          program_pdf_url: demoCourse.programPdfUrl,
          duration: demoCourse.duration,
          cpf_eligible: demoCourse.cpfEligible,
          opco_eligible: demoCourse.opcoEligible,
        }
      });

      console.log(`‚úÖ Formation cr√©√©e : ${demoCourse.title}`);

      // 4. Cr√©er les sessions avec dates futures
      if (demoCourse.sessions && demoCourse.sessions.length > 0) {
        const futureSessions = generateFutureSessions(course.id, demoCourse.sessions);
        
        for (const sessionData of futureSessions) {
          await prisma.session.create({
            data: sessionData
          });
        }
        
        console.log(`   üìÖ ${futureSessions.length} sessions cr√©√©es`);
      }
    }

    console.log('üéâ Migration termin√©e avec succ√®s !');
    
    // 5. Afficher un r√©sum√©
    const totalCourses = await prisma.course.count();
    const totalSessions = await prisma.session.count();
    const totalProviders = await prisma.trainingOrganization.count();
    
    console.log('\nüìä R√©sum√© :');
    console.log(`- Formations : ${totalCourses}`);
    console.log(`- Sessions : ${totalSessions}`);
    console.log(`- Organismes : ${totalProviders}`);

  } catch (error) {
    console.error('‚ùå Erreur lors de la migration :', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Ex√©cuter la migration
migrateDemoCourses()
  .catch(console.error)
  .finally(() => process.exit());